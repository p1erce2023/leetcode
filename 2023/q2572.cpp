#include <vector>
#include <unordered_set>
#include <algorithm>
#include <utility>
#include <iostream>
using std::vector;
using std::pair;
using std::unordered_set;

class Solution {
public:
    int MOD = 1e9 + 7;
    int squareFreeSubsets(vector<int>& nums, vector<pair<bool, vector<int>>>& mem, vector<int>& cnt, int i, unordered_set<int>& pf_c) {
        if (i == nums.size()) return 1;
        int ans = 0, x = nums[i];
        bool fit = true;
        vector<int>& pf = mem[x].second;
        for (int f : pf) {
            if (pf_c.find(f) != pf_c.end()) {
                fit = false;
                break;
            }
        }
        if (fit) { // backtrace
            ans = (0ll + ans + squareFreeSubsets(nums, mem, cnt, i + 1, pf_c)) % MOD;
            pf_c.insert(pf.begin(), pf.end());
            ans = (ans + 1ll * squareFreeSubsets(nums, mem, cnt, i + 1, pf_c) * cnt[x]) % MOD;
            for (int f : pf)
                pf_c.erase(f);
            return ans;
        } else {
            return squareFreeSubsets(nums, mem, cnt, i + 1, pf_c);
        }
    }

    int squareFreeSubsets(vector<int>& nums) {
        bool skip, br;
        int c, t;
        vector<int> pf;
        vector<pair<bool, vector<int>>> mem = {{false, {}}, {false, {}}};
        for (int j=2; j<=30; j++) {
            skip = false;
            t = j;
            for (int i = 2; i <= j; i += i == 2? 1 : 2) {
                c = 0;
                br = false;
                while (t % i == 0) {
                    c++;
                    if (c > 1) {
                        br = true;
                        break;
                    }
                    t = t / i;
                    pf.push_back(i);
                }
                if (br) {
                    skip = true;  // 本身违规
                    pf.clear();
                    break;
                }
            }
            if (!skip && pf.empty()) pf = {j};
            mem.push_back({skip, std::move(pf)});
        }
        // TLE 用去重，提前 skip square number
        vector<int> nnums, cnt(31, 0);
        for (int x : nums) {
            if (!mem[x].first) {
                if (cnt[x] == 0 && x != 1) nnums.push_back(x); // 1有特殊性，可以多次出现
                cnt[x]++;
            }
        }
        unordered_set<int> pf_c;
        long long xx = 1ll;
        for (int i = 0; i < cnt[1]; i++)
            xx = (xx << 1) % MOD;
        int y = squareFreeSubsets(nnums, mem, cnt, 0, pf_c);
        int ans = (xx * y - 1) % MOD;
        return ans >= 0? ans : ans + MOD;
    }
};

int main() {
    auto s = Solution();
    vector<int> nums;
    // nums = {3,4,4,5};
    // std::cout << s.squareFreeSubsets(nums) << std::endl;
    // nums = {1};
    // std::cout << s.squareFreeSubsets(nums) << std::endl;
    // nums = {1,2,6,15,7,19,6,29,28,24,21,25,25,18,9,6,20,21,8,24,14,19,24,28,30,27,13,21,1,23,13,29,24,29,18,7};
    // std::cout << s.squareFreeSubsets(nums) << std::endl;
    nums = {2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,30,30,30,30,30,30,30};
    std::cout << s.squareFreeSubsets(nums) << std::endl;
    return 0;
}